# MergeFS

## これは？

主に複数のディレクトリを単一のディレクトリとしてマウントするソフトウェアです。
プラグインにより、アーカイブファイルやCUEシートのマウントにも対応しています。
マウント自体には[Dokany](https://github.com/dokan-dev/dokany)ライブラリを使用しています。

### 具体的には

例えば、以下のようにディレクトリAとディレクトリBがあったとして、

- A
  - abc
  - def
    - ghi
- B
  - def
    - jkl
  - mno
    - pqr

これをディレクトリCに以下の通りにマウントします。

- C
  - abc
  - def
    - ghi
    - jkl
  - mno
    - pqr

マウント元のディレクトリAやディレクトリBのことを**マウントソース**（または単にソース）と呼び、マウント先のディレクトリCのことを**マウントポイント**と呼びます。

### マウントポイント

マウントポイントにはドライブか、NTFSファイルシステム上のディレクトリを指定できます。
ドライブを指定する場合は使われていないドライブレターを、NTFSファイルシステム上のディレクトリを指定する場合は既に存在するディレクトリを指定する必要があるようです。
他にもネットワークドライブとしてマウントすることも対応次第では可能なはずですが、この辺りの処理は全て[Dokany](https://github.com/dokan-dev/dokany)に委譲しているため、そちらをご覧ください。

### マウントソース

マウントソースとしてはファイルシステム上のディレクトリの他、アーカイブファイルやCUEシートを用いることができます。
これらのマウントソースの対応は、プラグインが行います。

マウントソースには書き込み可能なもの（たとえばファイルシステム上のディレクトリ）と書き込み不可能なもの（たとえばアーカイブファイルやCUEシート）があり、最初のマウントソースが書き込み可能である場合は、マウント先も書き込み可能になります。
このとき、書き込まれた変更は最初のマウントソースかメタデータに保存されます。

### メタデータ

メタデータはマウントソースのみでは表せない情報（変更）を表すために用いるデータです。
例えば、先のディレクトリA、Bの例で、A、Bの順でCにマウントしたとし、ここでC/mnoを削除することを考えます。
C/mnoの実体はBにありますが、Bは最初のマウントソースではないので変更を加えることができません。
ここで、C/mnoが削除済みであるということを記すためにメタデータが必要となります。
この他にも、例えばファイルの属性を変更したり、ファイルを移動する場合にIOを抑えるためにメタデータが使用されます。
現在メタデータは独自のバイナリ形式で保存されていますが、今後SQLite3に移す予定です。

### マウントソースの優先順位

マウントソースの優先順位は、競合するファイルやディレクトリが存在するときに必要になります。
つまり、同じ名前を持つファイルやディレクトリが複数のマウントソースに存在した場合、マウント先でどれを参照すれば良いかを判断するのに使われるのがマウントソースの優先順位です。
マウントソースの優先順位の規則は単純で、**先に指定されたものがより優先されます**。
例えば同じexampleという名前を持つファイルがマウントソースXとマウントソースYの双方に存在し、それらをあわせてZにマウントした場合、X、Yの順でマウントしていればZ/exampleはA/exampleを指し、反対にY、Zの順でマウントしていればZ/exampleはY/exampleを指します。

### マウント先での変更

最初のマウントソースが書き込み可能である場合は、マウント先も書き込み可能になります。
その際、加わった変更は最初のマウントソースに反映されます。
例えば、最初のディレクトリA、B、Cの例でA、Bの順にマウントしているとして、新たにC/stuを作成した場合、ディレクトリAにA/stuとして新たなファイルが作成されます。他に、C/mno/vwuを作成した場合、最初にA/mnoディレクトリがAに作成され、その後にA/mno/vwuが作成されます。

## プロジェクト構成

本プロジェクトは、コアである**LibMergeFS**と、クライアント、そしてプラグインの3種類からなります。

### コア

DLLの形式で、コア機能を担います。

- **LibMergeFS**
  各マウントソースを束ね、一つのマウントソースとしてDokanyに提供する役割を持ちます。
  C++で書かれています。

### クライアント（フロントエンド）

実行可能ファイルの形で、ユーザーにコアである**LibMergeFS**の機能を提供します。

- **MergeFS**
  GUIを備え、最終的にメインのフロントエンドにする予定のものです。
  C#で書く予定ですが、まだほとんど未完成です。C#書けない。誰か助けて。

- **MergeFSCC**
  CLIのフロントエンドです。
  もともとコア機能のテスト用に作成しましたが、これはこれでまた別のフロントエンドとして完成させる予定です。
  C++で書かれています。

### プラグイン

DLLの形式で、コア機能に様々な機能を追加します。

#### ソースプラグイン

現在提供する唯一のプラグイン形式です。
様々なもの（アーカイブファイルや実際のファイルシステム上のディレクトリ）をマウントできるようにします。

- **MFPSFileSystem**
  実際のファイルシステム上のディレクトリをマウントします。
  C++で書かれています。

- **MFPSArchive**
  アーカイブファイルをマウントします。
  アーカイブファイル内に存在するアーカイブファイルも再帰的にディレクトリとして読み込みます。
  非圧縮ファイル（tarボール等）など可能ならばメモリ上に展開せず直接データを読み取りますが、通常の圧縮ファイルの場合は最初にメモリ上に展開を行います。（コンパイル時オプションで変更も可能です。）
  アーカイブファイルの読み取りに[7-Zip](https://sevenzip.osdn.jp/)を使用しています。
  C++で書かれています。

- **MFPSCue**
  CUE+BIN、CUE+FLAC、CUE+WAVで保存された音楽ファイルをマウントします。
  CD-DAとしてではなく、各トラックごとに分割されたWAVファイル群としてマウントします。
  こちらもMFPSArchive同様全てをメモリ上に展開せず必要に応じてデコードするようにしています。（コンパイル時オプションで変更も可能です。）
  FLACのデコードに[libFLAC及びlibFLAC++](https://xiph.org/flac/)を使用しています。
  C++で書かれています。

- **MFPSNull**
  何も中身を持たない読み取り専用ソースです。
  先頭にこれを配置することで、読み取り専用マウントにできます。
  C++で書かれています。

- **MFPSMemory** （予定）
  メモリ上に書き込み可能なソースをマウントするものとして作成予定です。
  C++で書く予定です。

## ビルド方法

Windows環境とC++17に対応したコンパイラが必要です。
Microsoft Visual Studio 2017 (15.9.7) でのコンパイルを確認しています。

1. 外部ライブラリを追加します。
   現在、ソースツリーに外部ライブラリが不足しているため、最初にそれらを追加する必要があります。（今後Git submoduleとして追加する予定です）。

   - Dokanyの追加（LibMergeFS用）
     /（プロジェクトルートディレクトリ）以下にdokanディレクトリを作成し、Dokanyのインクルードファイルを追加してください。
     インクルードファイルはDokanyをインストールしたあと、C:\Program Files\Dokan\Dokan Library-1.2.1\include等に存在します。
     /dokan/dokan/dokan.hが存在すれば大丈夫です。

   - libFLAC、libFLAC++の追加（MFPSCue用）
     /MFPSCue/Vendor以下にflacディレクトリを作成し、[FLACのダウンロードページ](https://xiph.org/flac/download.html)からダウンロードしたFLACのソースコード（flac-1.3.2.tar.xzなど）をそこに展開してください。
     /MFPSCue/Vendor/flac/READMEが存在すれば大丈夫です。

   - 7-Zipの追加（MFPSArchive用）
     /MFPSArchive/Vendor以下に7zディレクトリを作成し、[7-Zipのダウンロードページ](https://sevenzip.osdn.jp/download.html)からダウンロードした7-Zipのソースコード（7z1806-src.7zなど）をそこに展開してください。
     /MFPSArchive/Vendor/7z/CPPが存在すれば大丈夫です。

2. /MergeFS.slnを開き、ビルドします。

## 未対応・未完成なもの

- [ ] 全機能を使用できるCLIフロントエンド
- [ ] GUIフロントエンド
- [ ] セキュリティ属性
- [ ] プラグインへのオプション
